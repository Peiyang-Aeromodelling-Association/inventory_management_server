// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: items.sql

package db

import (
	"context"
	"database/sql"
)

const createItem = `-- name: CreateItem :one
INSERT INTO items (identifier_code, name, holder, modification_time, modifier, description, deleted)
VALUES ($1, $2, $3, CURRENT_TIMESTAMP, $4, $5, FALSE)
RETURNING item_id, identifier_code, name, holder, modification_time, modifier, description, deleted
`

type CreateItemParams struct {
	IdentifierCode string         `json:"identifier_code"`
	Name           string         `json:"name"`
	Holder         int32          `json:"holder"`
	Modifier       int32          `json:"modifier"`
	Description    sql.NullString `json:"description"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Items, error) {
	row := q.db.QueryRowContext(ctx, createItem,
		arg.IdentifierCode,
		arg.Name,
		arg.Holder,
		arg.Modifier,
		arg.Description,
	)
	var i Items
	err := row.Scan(
		&i.ItemID,
		&i.IdentifierCode,
		&i.Name,
		&i.Holder,
		&i.ModificationTime,
		&i.Modifier,
		&i.Description,
		&i.Deleted,
	)
	return i, err
}

const deleteItem = `-- name: DeleteItem :one
UPDATE items
SET deleted           = TRUE,
    modification_time = CURRENT_TIMESTAMP,
    modifier          = $2
WHERE item_id = $1
RETURNING item_id, identifier_code, name, holder, modification_time, modifier, description, deleted
`

type DeleteItemParams struct {
	ItemID   int32 `json:"item_id"`
	Modifier int32 `json:"modifier"`
}

func (q *Queries) DeleteItem(ctx context.Context, arg DeleteItemParams) (Items, error) {
	row := q.db.QueryRowContext(ctx, deleteItem, arg.ItemID, arg.Modifier)
	var i Items
	err := row.Scan(
		&i.ItemID,
		&i.IdentifierCode,
		&i.Name,
		&i.Holder,
		&i.ModificationTime,
		&i.Modifier,
		&i.Description,
		&i.Deleted,
	)
	return i, err
}

const getItemsByHolder = `-- name: GetItemsByHolder :many
SELECT item_id, identifier_code, name, holder, modification_time, modifier, description, deleted
FROM items
WHERE holder = $1
  AND deleted = $2
`

type GetItemsByHolderParams struct {
	Holder  int32 `json:"holder"`
	Deleted bool  `json:"deleted"`
}

func (q *Queries) GetItemsByHolder(ctx context.Context, arg GetItemsByHolderParams) ([]Items, error) {
	rows, err := q.db.QueryContext(ctx, getItemsByHolder, arg.Holder, arg.Deleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Items{}
	for rows.Next() {
		var i Items
		if err := rows.Scan(
			&i.ItemID,
			&i.IdentifierCode,
			&i.Name,
			&i.Holder,
			&i.ModificationTime,
			&i.Modifier,
			&i.Description,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemsByIdentifierCode = `-- name: GetItemsByIdentifierCode :one
SELECT item_id, identifier_code, name, holder, modification_time, modifier, description, deleted
FROM items
WHERE identifier_code = $1
  AND deleted = $2
`

type GetItemsByIdentifierCodeParams struct {
	IdentifierCode string `json:"identifier_code"`
	Deleted        bool   `json:"deleted"`
}

func (q *Queries) GetItemsByIdentifierCode(ctx context.Context, arg GetItemsByIdentifierCodeParams) (Items, error) {
	row := q.db.QueryRowContext(ctx, getItemsByIdentifierCode, arg.IdentifierCode, arg.Deleted)
	var i Items
	err := row.Scan(
		&i.ItemID,
		&i.IdentifierCode,
		&i.Name,
		&i.Holder,
		&i.ModificationTime,
		&i.Modifier,
		&i.Description,
		&i.Deleted,
	)
	return i, err
}

const getItemsByIdentifierCodeForUpdate = `-- name: GetItemsByIdentifierCodeForUpdate :one
SELECT item_id, identifier_code, name, holder, modification_time, modifier, description, deleted
FROM items
WHERE identifier_code = $1
  AND deleted = $2
    FOR NO KEY UPDATE
`

type GetItemsByIdentifierCodeForUpdateParams struct {
	IdentifierCode string `json:"identifier_code"`
	Deleted        bool   `json:"deleted"`
}

func (q *Queries) GetItemsByIdentifierCodeForUpdate(ctx context.Context, arg GetItemsByIdentifierCodeForUpdateParams) (Items, error) {
	row := q.db.QueryRowContext(ctx, getItemsByIdentifierCodeForUpdate, arg.IdentifierCode, arg.Deleted)
	var i Items
	err := row.Scan(
		&i.ItemID,
		&i.IdentifierCode,
		&i.Name,
		&i.Holder,
		&i.ModificationTime,
		&i.Modifier,
		&i.Description,
		&i.Deleted,
	)
	return i, err
}

const getItemsByItemIdForUpdate = `-- name: GetItemsByItemIdForUpdate :one
SELECT item_id, identifier_code, name, holder, modification_time, modifier, description, deleted
FROM items
WHERE item_id = $1
    FOR NO KEY UPDATE
`

func (q *Queries) GetItemsByItemIdForUpdate(ctx context.Context, itemID int32) (Items, error) {
	row := q.db.QueryRowContext(ctx, getItemsByItemIdForUpdate, itemID)
	var i Items
	err := row.Scan(
		&i.ItemID,
		&i.IdentifierCode,
		&i.Name,
		&i.Holder,
		&i.ModificationTime,
		&i.Modifier,
		&i.Description,
		&i.Deleted,
	)
	return i, err
}

const getItemsByName = `-- name: GetItemsByName :many
SELECT item_id, identifier_code, name, holder, modification_time, modifier, description, deleted
FROM items
WHERE name = $1
  AND deleted = $2
`

type GetItemsByNameParams struct {
	Name    string `json:"name"`
	Deleted bool   `json:"deleted"`
}

func (q *Queries) GetItemsByName(ctx context.Context, arg GetItemsByNameParams) ([]Items, error) {
	rows, err := q.db.QueryContext(ctx, getItemsByName, arg.Name, arg.Deleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Items{}
	for rows.Next() {
		var i Items
		if err := rows.Scan(
			&i.ItemID,
			&i.IdentifierCode,
			&i.Name,
			&i.Holder,
			&i.ModificationTime,
			&i.Modifier,
			&i.Description,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
